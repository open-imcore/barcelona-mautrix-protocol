// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ipc/v1/v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum PBTapbackType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case tapbackNothing // = 0
  case tapbackLove // = 2000
  case tapbackLike // = 2001
  case tapbackDislike // = 2002
  case tapbackLaugh // = 2003
  case tapbackEmphasis // = 2004
  case tapbackQuestion // = 2005
  case tapbackRemoveLove // = 3000
  case tapbackRemoveLike // = 3001
  case tapbackRemoveDislike // = 3002
  case tapbackRemoveLaugh // = 3003
  case tapbackRemoveEmphasis // = 3004
  case tapbackRemoveQuestion // = 3005
  case UNRECOGNIZED(Int)

  public init() {
    self = .tapbackNothing
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tapbackNothing
    case 2000: self = .tapbackLove
    case 2001: self = .tapbackLike
    case 2002: self = .tapbackDislike
    case 2003: self = .tapbackLaugh
    case 2004: self = .tapbackEmphasis
    case 2005: self = .tapbackQuestion
    case 3000: self = .tapbackRemoveLove
    case 3001: self = .tapbackRemoveLike
    case 3002: self = .tapbackRemoveDislike
    case 3003: self = .tapbackRemoveLaugh
    case 3004: self = .tapbackRemoveEmphasis
    case 3005: self = .tapbackRemoveQuestion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tapbackNothing: return 0
    case .tapbackLove: return 2000
    case .tapbackLike: return 2001
    case .tapbackDislike: return 2002
    case .tapbackLaugh: return 2003
    case .tapbackEmphasis: return 2004
    case .tapbackQuestion: return 2005
    case .tapbackRemoveLove: return 3000
    case .tapbackRemoveLike: return 3001
    case .tapbackRemoveDislike: return 3002
    case .tapbackRemoveLaugh: return 3003
    case .tapbackRemoveEmphasis: return 3004
    case .tapbackRemoveQuestion: return 3005
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBTapbackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBTapbackType] = [
    .tapbackNothing,
    .tapbackLove,
    .tapbackLike,
    .tapbackDislike,
    .tapbackLaugh,
    .tapbackEmphasis,
    .tapbackQuestion,
    .tapbackRemoveLove,
    .tapbackRemoveLike,
    .tapbackRemoveDislike,
    .tapbackRemoveLaugh,
    .tapbackRemoveEmphasis,
    .tapbackRemoveQuestion,
  ]
}

#endif  // swift(>=4.2)

public enum PBItemType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case message // = 0
  case member // = 1
  case name // = 2
  case avatar // = 4
  case error // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .message
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .message
    case 1: self = .member
    case 2: self = .name
    case 4: self = .avatar
    case 5: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .message: return 0
    case .member: return 1
    case .name: return 2
    case .avatar: return 4
    case .error: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBItemType] = [
    .message,
    .member,
    .name,
    .avatar,
    .error,
  ]
}

#endif  // swift(>=4.2)

public enum PBGroupActionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case groupActionAdd // = 0
  case groupActionRemove // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .groupActionAdd
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .groupActionAdd
    case 1: self = .groupActionRemove
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .groupActionAdd: return 0
    case .groupActionRemove: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBGroupActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBGroupActionType] = [
    .groupActionAdd,
    .groupActionRemove,
  ]
}

#endif  // swift(>=4.2)

public struct PBGUID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var service: String = String()

  public var isGroup: Bool = false

  public var localID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBMessageTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String = String()

  public var part: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBTapback {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: String = String()

  public var type: PBTapbackType = .tapbackNothing

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String {
    get {return _guid ?? String()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  public var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  public mutating func clearGuid() {self._guid = nil}

  public var pathOnDisk: String = String()

  public var fileName: String = String()

  public var mimeType: String {
    get {return _mimeType ?? String()}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  public var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  public mutating func clearMimeType() {self._mimeType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _guid: String? = nil
  fileprivate var _mimeType: String? = nil
}

public struct PBRichLinkAssetSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: PBRichLinkAssetSource.OneOf_Source? = nil

  public var url: String {
    get {
      if case .url(let v)? = source {return v}
      return String()
    }
    set {source = .url(newValue)}
  }

  public var data: Data {
    get {
      if case .data(let v)? = source {return v}
      return Data()
    }
    set {source = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Source: Equatable {
    case url(String)
    case data(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: PBRichLinkAssetSource.OneOf_Source, rhs: PBRichLinkAssetSource.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.url, .url): return {
        guard case .url(let l) = lhs, case .url(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBRichLinkAssetSize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int64 = 0

  public var height: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBRichLinkAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mimeType: String {
    get {return _mimeType ?? String()}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  public var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  public mutating func clearMimeType() {self._mimeType = nil}

  public var accessibilityText: String {
    get {return _accessibilityText ?? String()}
    set {_accessibilityText = newValue}
  }
  /// Returns true if `accessibilityText` has been explicitly set.
  public var hasAccessibilityText: Bool {return self._accessibilityText != nil}
  /// Clears the value of `accessibilityText`. Subsequent reads from it will return its default value.
  public mutating func clearAccessibilityText() {self._accessibilityText = nil}

  public var source: PBRichLinkAssetSource {
    get {return _source ?? PBRichLinkAssetSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var originalURL: String {
    get {return _originalURL ?? String()}
    set {_originalURL = newValue}
  }
  /// Returns true if `originalURL` has been explicitly set.
  public var hasOriginalURL: Bool {return self._originalURL != nil}
  /// Clears the value of `originalURL`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalURL() {self._originalURL = nil}

  public var size: PBRichLinkAssetSize {
    get {return _size ?? PBRichLinkAssetSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mimeType: String? = nil
  fileprivate var _accessibilityText: String? = nil
  fileprivate var _source: PBRichLinkAssetSource? = nil
  fileprivate var _originalURL: String? = nil
  fileprivate var _size: PBRichLinkAssetSize? = nil
}

public struct PBRichLinkVideoAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hasAudio_p: Bool = false

  public var youTubeURL: String {
    get {return _youTubeURL ?? String()}
    set {_youTubeURL = newValue}
  }
  /// Returns true if `youTubeURL` has been explicitly set.
  public var hasYouTubeURL: Bool {return self._youTubeURL != nil}
  /// Clears the value of `youTubeURL`. Subsequent reads from it will return its default value.
  public mutating func clearYouTubeURL() {self._youTubeURL = nil}

  public var streamingURL: String {
    get {return _streamingURL ?? String()}
    set {_streamingURL = newValue}
  }
  /// Returns true if `streamingURL` has been explicitly set.
  public var hasStreamingURL: Bool {return self._streamingURL != nil}
  /// Clears the value of `streamingURL`. Subsequent reads from it will return its default value.
  public mutating func clearStreamingURL() {self._streamingURL = nil}

  public var asset: PBRichLinkAsset {
    get {return _asset ?? PBRichLinkAsset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _youTubeURL: String? = nil
  fileprivate var _streamingURL: String? = nil
  fileprivate var _asset: PBRichLinkAsset? = nil
}

public struct PBRichLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var originalURL: String {
    get {return _storage._originalURL ?? String()}
    set {_uniqueStorage()._originalURL = newValue}
  }
  /// Returns true if `originalURL` has been explicitly set.
  public var hasOriginalURL: Bool {return _storage._originalURL != nil}
  /// Clears the value of `originalURL`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalURL() {_uniqueStorage()._originalURL = nil}

  public var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {_uniqueStorage()._url = nil}

  public var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var summary: String {
    get {return _storage._summary ?? String()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var selectedText: String {
    get {return _storage._selectedText ?? String()}
    set {_uniqueStorage()._selectedText = newValue}
  }
  /// Returns true if `selectedText` has been explicitly set.
  public var hasSelectedText: Bool {return _storage._selectedText != nil}
  /// Clears the value of `selectedText`. Subsequent reads from it will return its default value.
  public mutating func clearSelectedText() {_uniqueStorage()._selectedText = nil}

  public var siteName: String {
    get {return _storage._siteName ?? String()}
    set {_uniqueStorage()._siteName = newValue}
  }
  /// Returns true if `siteName` has been explicitly set.
  public var hasSiteName: Bool {return _storage._siteName != nil}
  /// Clears the value of `siteName`. Subsequent reads from it will return its default value.
  public mutating func clearSiteName() {_uniqueStorage()._siteName = nil}

  public var relatedURL: String {
    get {return _storage._relatedURL ?? String()}
    set {_uniqueStorage()._relatedURL = newValue}
  }
  /// Returns true if `relatedURL` has been explicitly set.
  public var hasRelatedURL: Bool {return _storage._relatedURL != nil}
  /// Clears the value of `relatedURL`. Subsequent reads from it will return its default value.
  public mutating func clearRelatedURL() {_uniqueStorage()._relatedURL = nil}

  public var creator: String {
    get {return _storage._creator ?? String()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var creatorFacebookProfile: String {
    get {return _storage._creatorFacebookProfile ?? String()}
    set {_uniqueStorage()._creatorFacebookProfile = newValue}
  }
  /// Returns true if `creatorFacebookProfile` has been explicitly set.
  public var hasCreatorFacebookProfile: Bool {return _storage._creatorFacebookProfile != nil}
  /// Clears the value of `creatorFacebookProfile`. Subsequent reads from it will return its default value.
  public mutating func clearCreatorFacebookProfile() {_uniqueStorage()._creatorFacebookProfile = nil}

  public var creatorTwitterUsername: String {
    get {return _storage._creatorTwitterUsername ?? String()}
    set {_uniqueStorage()._creatorTwitterUsername = newValue}
  }
  /// Returns true if `creatorTwitterUsername` has been explicitly set.
  public var hasCreatorTwitterUsername: Bool {return _storage._creatorTwitterUsername != nil}
  /// Clears the value of `creatorTwitterUsername`. Subsequent reads from it will return its default value.
  public mutating func clearCreatorTwitterUsername() {_uniqueStorage()._creatorTwitterUsername = nil}

  public var itemType: String {
    get {return _storage._itemType ?? String()}
    set {_uniqueStorage()._itemType = newValue}
  }
  /// Returns true if `itemType` has been explicitly set.
  public var hasItemType: Bool {return _storage._itemType != nil}
  /// Clears the value of `itemType`. Subsequent reads from it will return its default value.
  public mutating func clearItemType() {_uniqueStorage()._itemType = nil}

  public var icon: PBRichLinkAsset {
    get {return _storage._icon ?? PBRichLinkAsset()}
    set {_uniqueStorage()._icon = newValue}
  }
  /// Returns true if `icon` has been explicitly set.
  public var hasIcon: Bool {return _storage._icon != nil}
  /// Clears the value of `icon`. Subsequent reads from it will return its default value.
  public mutating func clearIcon() {_uniqueStorage()._icon = nil}

  public var image: PBRichLinkAsset {
    get {return _storage._image ?? PBRichLinkAsset()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var video: PBRichLinkVideoAsset {
    get {return _storage._video ?? PBRichLinkVideoAsset()}
    set {_uniqueStorage()._video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return _storage._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {_uniqueStorage()._video = nil}

  public var audio: PBRichLinkAsset {
    get {return _storage._audio ?? PBRichLinkAsset()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {_uniqueStorage()._audio = nil}

  public var images: [PBRichLinkAsset] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  public var videos: [PBRichLinkAsset] {
    get {return _storage._videos}
    set {_uniqueStorage()._videos = newValue}
  }

  public var streamingVideos: [PBRichLinkAsset] {
    get {return _storage._streamingVideos}
    set {_uniqueStorage()._streamingVideos = newValue}
  }

  public var audios: [PBRichLinkAsset] {
    get {return _storage._audios}
    set {_uniqueStorage()._audios = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PBArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [PBMetadataValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mapping: Dictionary<String,PBMetadataValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBMetadataValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: PBMetadataValue.OneOf_Value? = nil

  public var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  public var double: Double {
    get {
      if case .double(let v)? = value {return v}
      return 0
    }
    set {value = .double(newValue)}
  }

  public var float: Float {
    get {
      if case .float(let v)? = value {return v}
      return 0
    }
    set {value = .float(newValue)}
  }

  public var int32: Int32 {
    get {
      if case .int32(let v)? = value {return v}
      return 0
    }
    set {value = .int32(newValue)}
  }

  public var int64: Int64 {
    get {
      if case .int64(let v)? = value {return v}
      return 0
    }
    set {value = .int64(newValue)}
  }

  public var uint32: UInt32 {
    get {
      if case .uint32(let v)? = value {return v}
      return 0
    }
    set {value = .uint32(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = value {return v}
      return 0
    }
    set {value = .uint64(newValue)}
  }

  public var sint32: Int32 {
    get {
      if case .sint32(let v)? = value {return v}
      return 0
    }
    set {value = .sint32(newValue)}
  }

  public var sint64: Int64 {
    get {
      if case .sint64(let v)? = value {return v}
      return 0
    }
    set {value = .sint64(newValue)}
  }

  public var fixed32: UInt32 {
    get {
      if case .fixed32(let v)? = value {return v}
      return 0
    }
    set {value = .fixed32(newValue)}
  }

  public var fixed64: UInt64 {
    get {
      if case .fixed64(let v)? = value {return v}
      return 0
    }
    set {value = .fixed64(newValue)}
  }

  public var sfixed32: Int32 {
    get {
      if case .sfixed32(let v)? = value {return v}
      return 0
    }
    set {value = .sfixed32(newValue)}
  }

  public var sfixed64: Int64 {
    get {
      if case .sfixed64(let v)? = value {return v}
      return 0
    }
    set {value = .sfixed64(newValue)}
  }

  public var bool: Bool {
    get {
      if case .bool(let v)? = value {return v}
      return false
    }
    set {value = .bool(newValue)}
  }

  public var bytes: Data {
    get {
      if case .bytes(let v)? = value {return v}
      return Data()
    }
    set {value = .bytes(newValue)}
  }

  public var array: PBArray {
    get {
      if case .array(let v)? = value {return v}
      return PBArray()
    }
    set {value = .array(newValue)}
  }

  public var mapping: PBMapping {
    get {
      if case .mapping(let v)? = value {return v}
      return PBMapping()
    }
    set {value = .mapping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case string(String)
    case double(Double)
    case float(Float)
    case int32(Int32)
    case int64(Int64)
    case uint32(UInt32)
    case uint64(UInt64)
    case sint32(Int32)
    case sint64(Int64)
    case fixed32(UInt32)
    case fixed64(UInt64)
    case sfixed32(Int32)
    case sfixed64(Int64)
    case bool(Bool)
    case bytes(Data)
    case array(PBArray)
    case mapping(PBMapping)

  #if !swift(>=4.1)
    public static func ==(lhs: PBMetadataValue.OneOf_Value, rhs: PBMetadataValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.double, .double): return {
        guard case .double(let l) = lhs, case .double(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.float, .float): return {
        guard case .float(let l) = lhs, case .float(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int32, .int32): return {
        guard case .int32(let l) = lhs, case .int32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64, .int64): return {
        guard case .int64(let l) = lhs, case .int64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint32, .uint32): return {
        guard case .uint32(let l) = lhs, case .uint32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint64, .uint64): return {
        guard case .uint64(let l) = lhs, case .uint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sint32, .sint32): return {
        guard case .sint32(let l) = lhs, case .sint32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sint64, .sint64): return {
        guard case .sint64(let l) = lhs, case .sint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixed32, .fixed32): return {
        guard case .fixed32(let l) = lhs, case .fixed32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixed64, .fixed64): return {
        guard case .fixed64(let l) = lhs, case .fixed64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sfixed32, .sfixed32): return {
        guard case .sfixed32(let l) = lhs, case .sfixed32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sfixed64, .sfixed64): return {
        guard case .sfixed64(let l) = lhs, case .sfixed64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapping, .mapping): return {
        guard case .mapping(let l) = lhs, case .mapping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBCorrelations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: String {
    get {return _sender ?? String()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var chat: String {
    get {return _chat ?? String()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: String? = nil
  fileprivate var _chat: String? = nil
}

public struct PBTextItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var subject: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBAttachmentItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachment: PBAttachment {
    get {return _attachment ?? PBAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: PBAttachment? = nil
}

public struct PBTypingItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBPluginItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var richLink: PBRichLink {
    get {return _richLink ?? PBRichLink()}
    set {_richLink = newValue}
  }
  /// Returns true if `richLink` has been explicitly set.
  public var hasRichLink: Bool {return self._richLink != nil}
  /// Clears the value of `richLink`. Subsequent reads from it will return its default value.
  public mutating func clearRichLink() {self._richLink = nil}

  public var attachments: [PBAttachment] = []

  public var fallbackText: String {
    get {return _fallbackText ?? String()}
    set {_fallbackText = newValue}
  }
  /// Returns true if `fallbackText` has been explicitly set.
  public var hasFallbackText: Bool {return self._fallbackText != nil}
  /// Clears the value of `fallbackText`. Subsequent reads from it will return its default value.
  public mutating func clearFallbackText() {self._fallbackText = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _richLink: PBRichLink? = nil
  fileprivate var _fallbackText: String? = nil
}

public struct PBGroupNameChangeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _title: String? = nil
}

public struct PBGroupAvatarChangeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: PBGroupActionType = .groupActionAdd

  public var newAvatar: PBAttachment {
    get {return _newAvatar ?? PBAttachment()}
    set {_newAvatar = newValue}
  }
  /// Returns true if `newAvatar` has been explicitly set.
  public var hasNewAvatar: Bool {return self._newAvatar != nil}
  /// Clears the value of `newAvatar`. Subsequent reads from it will return its default value.
  public mutating func clearNewAvatar() {self._newAvatar = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newAvatar: PBAttachment? = nil
}

public struct PBGroupParticipantChangeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: PBGroupActionType = .groupActionAdd

  public var target: String {
    get {return _target ?? String()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {self._target = nil}

  public var initiator: String {
    get {return _initiator ?? String()}
    set {_initiator = newValue}
  }
  /// Returns true if `initiator` has been explicitly set.
  public var hasInitiator: Bool {return self._initiator != nil}
  /// Clears the value of `initiator`. Subsequent reads from it will return its default value.
  public mutating func clearInitiator() {self._initiator = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: String? = nil
  fileprivate var _initiator: String? = nil
}

public struct PBTapbackItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tapback: PBTapback {
    get {return _tapback ?? PBTapback()}
    set {_tapback = newValue}
  }
  /// Returns true if `tapback` has been explicitly set.
  public var hasTapback: Bool {return self._tapback != nil}
  /// Clears the value of `tapback`. Subsequent reads from it will return its default value.
  public mutating func clearTapback() {self._tapback = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tapback: PBTapback? = nil
}

public struct PBPhantomItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeString: String = String()

  public var debugDescription_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String = String()

  public var ___: PBItem.OneOf__? = nil

  public var text: PBTextItem {
    get {
      if case .text(let v)? = ___ {return v}
      return PBTextItem()
    }
    set {___ = .text(newValue)}
  }

  public var attachment: PBAttachmentItem {
    get {
      if case .attachment(let v)? = ___ {return v}
      return PBAttachmentItem()
    }
    set {___ = .attachment(newValue)}
  }

  public var typing: PBTypingItem {
    get {
      if case .typing(let v)? = ___ {return v}
      return PBTypingItem()
    }
    set {___ = .typing(newValue)}
  }

  public var plugin: PBPluginItem {
    get {
      if case .plugin(let v)? = ___ {return v}
      return PBPluginItem()
    }
    set {___ = .plugin(newValue)}
  }

  public var groupNameChange: PBGroupNameChangeItem {
    get {
      if case .groupNameChange(let v)? = ___ {return v}
      return PBGroupNameChangeItem()
    }
    set {___ = .groupNameChange(newValue)}
  }

  public var groupAvatarChange: PBGroupAvatarChangeItem {
    get {
      if case .groupAvatarChange(let v)? = ___ {return v}
      return PBGroupAvatarChangeItem()
    }
    set {___ = .groupAvatarChange(newValue)}
  }

  public var groupParticipantChange: PBGroupParticipantChangeItem {
    get {
      if case .groupParticipantChange(let v)? = ___ {return v}
      return PBGroupParticipantChangeItem()
    }
    set {___ = .groupParticipantChange(newValue)}
  }

  public var tapback: PBTapbackItem {
    get {
      if case .tapback(let v)? = ___ {return v}
      return PBTapbackItem()
    }
    set {___ = .tapback(newValue)}
  }

  public var phantom: PBPhantomItem {
    get {
      if case .phantom(let v)? = ___ {return v}
      return PBPhantomItem()
    }
    set {___ = .phantom(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf__: Equatable {
    case text(PBTextItem)
    case attachment(PBAttachmentItem)
    case typing(PBTypingItem)
    case plugin(PBPluginItem)
    case groupNameChange(PBGroupNameChangeItem)
    case groupAvatarChange(PBGroupAvatarChangeItem)
    case groupParticipantChange(PBGroupParticipantChangeItem)
    case tapback(PBTapbackItem)
    case phantom(PBPhantomItem)

  #if !swift(>=4.1)
    public static func ==(lhs: PBItem.OneOf__, rhs: PBItem.OneOf__) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attachment, .attachment): return {
        guard case .attachment(let l) = lhs, case .attachment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typing, .typing): return {
        guard case .typing(let l) = lhs, case .typing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.plugin, .plugin): return {
        guard case .plugin(let l) = lhs, case .plugin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupNameChange, .groupNameChange): return {
        guard case .groupNameChange(let l) = lhs, case .groupNameChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupAvatarChange, .groupAvatarChange): return {
        guard case .groupAvatarChange(let l) = lhs, case .groupAvatarChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupParticipantChange, .groupParticipantChange): return {
        guard case .groupParticipantChange(let l) = lhs, case .groupParticipantChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tapback, .tapback): return {
        guard case .tapback(let l) = lhs, case .tapback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.phantom, .phantom): return {
        guard case .phantom(let l) = lhs, case .phantom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String {
    get {return _storage._guid}
    set {_uniqueStorage()._guid = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  ///    optional string Subject = 3;
  ///    string Text = 4;
  public var chatGuid: PBGUID {
    get {return _storage._chatGuid ?? PBGUID()}
    set {_uniqueStorage()._chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return _storage._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {_uniqueStorage()._chatGuid = nil}

  public var sender: PBGUID {
    get {return _storage._sender ?? PBGUID()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {_uniqueStorage()._sender = nil}

  /// optional GUID Target = 7;
  public var isFromMe: Bool {
    get {return _storage._isFromMe}
    set {_uniqueStorage()._isFromMe = newValue}
  }

  public var isRead: Bool {
    get {return _storage._isRead}
    set {_uniqueStorage()._isRead = newValue}
  }

  public var readAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._readAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  public var hasReadAt: Bool {return _storage._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  public mutating func clearReadAt() {_uniqueStorage()._readAt = nil}

  public var isDelivered: Bool {
    get {return _storage._isDelivered}
    set {_uniqueStorage()._isDelivered = newValue}
  }

  public var isSent: Bool {
    get {return _storage._isSent}
    set {_uniqueStorage()._isSent = newValue}
  }

  ///    bool IsEmote = 13;
  public var isAudioMessage: Bool {
    get {return _storage._isAudioMessage}
    set {_uniqueStorage()._isAudioMessage = newValue}
  }

  public var threadTarget: PBMessageTarget {
    get {return _storage._threadTarget ?? PBMessageTarget()}
    set {_uniqueStorage()._threadTarget = newValue}
  }
  /// Returns true if `threadTarget` has been explicitly set.
  public var hasThreadTarget: Bool {return _storage._threadTarget != nil}
  /// Clears the value of `threadTarget`. Subsequent reads from it will return its default value.
  public mutating func clearThreadTarget() {_uniqueStorage()._threadTarget = nil}

  /// optional Tapback Tapback = 16;
  /// repeated Attachment attachments = 17;
  public var errorNotice: String {
    get {return _storage._errorNotice ?? String()}
    set {_uniqueStorage()._errorNotice = newValue}
  }
  /// Returns true if `errorNotice` has been explicitly set.
  public var hasErrorNotice: Bool {return _storage._errorNotice != nil}
  /// Clears the value of `errorNotice`. Subsequent reads from it will return its default value.
  public mutating func clearErrorNotice() {_uniqueStorage()._errorNotice = nil}

  /// ItemType ItemType = 19;
  /// optional GroupActionType GroupActionType = 20;
  /// optional string NewGroupName = 21;
  /// optional RichLink RichLink = 22;
  public var messageMetadata: PBMapping {
    get {return _storage._messageMetadata ?? PBMapping()}
    set {_uniqueStorage()._messageMetadata = newValue}
  }
  /// Returns true if `messageMetadata` has been explicitly set.
  public var hasMessageMetadata: Bool {return _storage._messageMetadata != nil}
  /// Clears the value of `messageMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearMessageMetadata() {_uniqueStorage()._messageMetadata = nil}

  public var correlations: PBCorrelations {
    get {return _storage._correlations ?? PBCorrelations()}
    set {_uniqueStorage()._correlations = newValue}
  }
  /// Returns true if `correlations` has been explicitly set.
  public var hasCorrelations: Bool {return _storage._correlations != nil}
  /// Clears the value of `correlations`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelations() {_uniqueStorage()._correlations = nil}

  public var service: String {
    get {return _storage._service}
    set {_uniqueStorage()._service = newValue}
  }

  public var items: [PBItem] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PBReadReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senderGuid: PBGUID {
    get {return _senderGuid ?? PBGUID()}
    set {_senderGuid = newValue}
  }
  /// Returns true if `senderGuid` has been explicitly set.
  public var hasSenderGuid: Bool {return self._senderGuid != nil}
  /// Clears the value of `senderGuid`. Subsequent reads from it will return its default value.
  public mutating func clearSenderGuid() {self._senderGuid = nil}

  public var isFromMe: Bool = false

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var readUpTo: String = String()

  public var readAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  public var hasReadAt: Bool {return self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  public mutating func clearReadAt() {self._readAt = nil}

  public var correlations: PBCorrelations {
    get {return _correlations ?? PBCorrelations()}
    set {_correlations = newValue}
  }
  /// Returns true if `correlations` has been explicitly set.
  public var hasCorrelations: Bool {return self._correlations != nil}
  /// Clears the value of `correlations`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelations() {self._correlations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderGuid: PBGUID? = nil
  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _readAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _correlations: PBCorrelations? = nil
}

public struct PBTypingNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var typing: Bool = false

  public var correlations: PBCorrelations {
    get {return _correlations ?? PBCorrelations()}
    set {_correlations = newValue}
  }
  /// Returns true if `correlations` has been explicitly set.
  public var hasCorrelations: Bool {return self._correlations != nil}
  /// Clears the value of `correlations`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelations() {self._correlations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _correlations: PBCorrelations? = nil
}

public struct PBContact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var firstName: String {
    get {return _firstName ?? String()}
    set {_firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  public var hasFirstName: Bool {return self._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  public mutating func clearFirstName() {self._firstName = nil}

  public var lastName: String {
    get {return _lastName ?? String()}
    set {_lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  public var hasLastName: Bool {return self._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  public mutating func clearLastName() {self._lastName = nil}

  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  public var avatar: Data {
    get {return _avatar ?? Data()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  public var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  public mutating func clearAvatar() {self._avatar = nil}

  public var phones: [String] = []

  public var emails: [String] = []

  public var userGuid: PBGUID {
    get {return _userGuid ?? PBGUID()}
    set {_userGuid = newValue}
  }
  /// Returns true if `userGuid` has been explicitly set.
  public var hasUserGuid: Bool {return self._userGuid != nil}
  /// Clears the value of `userGuid`. Subsequent reads from it will return its default value.
  public mutating func clearUserGuid() {self._userGuid = nil}

  public var primaryIdentifier: String {
    get {return _primaryIdentifier ?? String()}
    set {_primaryIdentifier = newValue}
  }
  /// Returns true if `primaryIdentifier` has been explicitly set.
  public var hasPrimaryIdentifier: Bool {return self._primaryIdentifier != nil}
  /// Clears the value of `primaryIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryIdentifier() {self._primaryIdentifier = nil}

  public var correlationID: String {
    get {return _correlationID ?? String()}
    set {_correlationID = newValue}
  }
  /// Returns true if `correlationID` has been explicitly set.
  public var hasCorrelationID: Bool {return self._correlationID != nil}
  /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelationID() {self._correlationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _firstName: String? = nil
  fileprivate var _lastName: String? = nil
  fileprivate var _nickname: String? = nil
  fileprivate var _avatar: Data? = nil
  fileprivate var _userGuid: PBGUID? = nil
  fileprivate var _primaryIdentifier: String? = nil
  fileprivate var _correlationID: String? = nil
}

public struct PBChatInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: PBGUID {
    get {return _guid ?? PBGUID()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  public var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  public mutating func clearGuid() {self._guid = nil}

  public var displayName: String {
    get {return _displayName ?? String()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  public var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayName() {self._displayName = nil}

  public var members: [String] = []

  public var noCreateRoom: Bool {
    get {return _noCreateRoom ?? false}
    set {_noCreateRoom = newValue}
  }
  /// Returns true if `noCreateRoom` has been explicitly set.
  public var hasNoCreateRoom: Bool {return self._noCreateRoom != nil}
  /// Clears the value of `noCreateRoom`. Subsequent reads from it will return its default value.
  public mutating func clearNoCreateRoom() {self._noCreateRoom = nil}

  public var correlationID: String {
    get {return _correlationID ?? String()}
    set {_correlationID = newValue}
  }
  /// Returns true if `correlationID` has been explicitly set.
  public var hasCorrelationID: Bool {return self._correlationID != nil}
  /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelationID() {self._correlationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _guid: PBGUID? = nil
  fileprivate var _displayName: String? = nil
  fileprivate var _noCreateRoom: Bool? = nil
  fileprivate var _correlationID: String? = nil
}

public struct PBSendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String = String()

  public var service: String = String()

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct PBSendResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: PBSendResult.OneOf_Result? = nil

  public var sendResponse: PBSendResponse {
    get {
      if case .sendResponse(let v)? = result {return v}
      return PBSendResponse()
    }
    set {result = .sendResponse(newValue)}
  }

  public var error: PBError {
    get {
      if case .error(let v)? = result {return v}
      return PBError()
    }
    set {result = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case sendResponse(PBSendResponse)
    case error(PBError)

  #if !swift(>=4.1)
    public static func ==(lhs: PBSendResult.OneOf_Result, rhs: PBSendResult.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sendResponse, .sendResponse): return {
        guard case .sendResponse(let l) = lhs, case .sendResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBSendMessageStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String = String()

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var status: String = String()

  public var service: String = String()

  public var error: PBError {
    get {return _error ?? PBError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var correlations: PBCorrelations {
    get {return _correlations ?? PBCorrelations()}
    set {_correlations = newValue}
  }
  /// Returns true if `correlations` has been explicitly set.
  public var hasCorrelations: Bool {return self._correlations != nil}
  /// Clears the value of `correlations`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelations() {self._correlations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _error: PBError? = nil
  fileprivate var _correlations: PBCorrelations? = nil
}

public struct PBStartupSyncHookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var skipSync: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBSendTextMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var richLink: PBRichLink {
    get {return _richLink ?? PBRichLink()}
    set {_richLink = newValue}
  }
  /// Returns true if `richLink` has been explicitly set.
  public var hasRichLink: Bool {return self._richLink != nil}
  /// Clears the value of `richLink`. Subsequent reads from it will return its default value.
  public mutating func clearRichLink() {self._richLink = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _richLink: PBRichLink? = nil
}

public struct PBSendMediaMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var attachment: PBAttachment {
    get {return _attachment ?? PBAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var isAudioMessage: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: PBAttachment? = nil
}

public struct PBSendTapbackMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: PBMessageTarget {
    get {return _target ?? PBMessageTarget()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {self._target = nil}

  public var type: PBTapbackType = .tapbackNothing

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: PBMessageTarget? = nil
}

public struct PBSendMessagePart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var part: PBSendMessagePart.OneOf_Part? = nil

  public var text: PBSendTextMessageRequest {
    get {
      if case .text(let v)? = part {return v}
      return PBSendTextMessageRequest()
    }
    set {part = .text(newValue)}
  }

  public var media: PBSendMediaMessageRequest {
    get {
      if case .media(let v)? = part {return v}
      return PBSendMediaMessageRequest()
    }
    set {part = .media(newValue)}
  }

  public var tapback: PBSendTapbackMessageRequest {
    get {
      if case .tapback(let v)? = part {return v}
      return PBSendTapbackMessageRequest()
    }
    set {part = .tapback(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Part: Equatable {
    case text(PBSendTextMessageRequest)
    case media(PBSendMediaMessageRequest)
    case tapback(PBSendTapbackMessageRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: PBSendMessagePart.OneOf_Part, rhs: PBSendMessagePart.OneOf_Part) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.media, .media): return {
        guard case .media(let l) = lhs, case .media(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tapback, .tapback): return {
        guard case .tapback(let l) = lhs, case .tapback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBSendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var replyTarget: PBMessageTarget {
    get {return _replyTarget ?? PBMessageTarget()}
    set {_replyTarget = newValue}
  }
  /// Returns true if `replyTarget` has been explicitly set.
  public var hasReplyTarget: Bool {return self._replyTarget != nil}
  /// Clears the value of `replyTarget`. Subsequent reads from it will return its default value.
  public mutating func clearReplyTarget() {self._replyTarget = nil}

  public var metadata: PBMapping {
    get {return _metadata ?? PBMapping()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var parts: [PBSendMessagePart] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _replyTarget: PBMessageTarget? = nil
  fileprivate var _metadata: PBMapping? = nil
}

public struct PBSendReadReceiptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var readUpTo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
}

public struct PBSetTypingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var typing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
}

public struct PBGetChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
}

public struct PBGetChatAvatarRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
}

public struct PBGetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _minTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_minTimestamp = newValue}
  }
  /// Returns true if `minTimestamp` has been explicitly set.
  public var hasMinTimestamp: Bool {return self._minTimestamp != nil}
  /// Clears the value of `minTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearMinTimestamp() {self._minTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct PBGetContactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBGetRecentMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var limit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
}

public struct PBGetMessagesAfterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var limit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct PBResolveIdentifierRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBResolveIdentifierResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: PBGUID {
    get {return _guid ?? PBGUID()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  public var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  public mutating func clearGuid() {self._guid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _guid: PBGUID? = nil
}

public struct PBResolveIdentifierResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: PBResolveIdentifierResult.OneOf_Result? = nil

  public var response: PBResolveIdentifierResponse {
    get {
      if case .response(let v)? = result {return v}
      return PBResolveIdentifierResponse()
    }
    set {result = .response(newValue)}
  }

  public var error: PBError {
    get {
      if case .error(let v)? = result {return v}
      return PBError()
    }
    set {result = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case response(PBResolveIdentifierResponse)
    case error(PBError)

  #if !swift(>=4.1)
    public static func ==(lhs: PBResolveIdentifierResult.OneOf_Result, rhs: PBResolveIdentifierResult.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBPrepareDMRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: PBGUID {
    get {return _guid ?? PBGUID()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  public var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  public mutating func clearGuid() {self._guid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _guid: PBGUID? = nil
}

public struct PBLogLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var level: String = String()

  public var module: String = String()

  public var metadata: PBMapping {
    get {return _metadata ?? PBMapping()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: PBMapping? = nil
}

public struct PBBridgeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stateEvent: String = String()

  public var timestamp: Int64 = 0

  public var ttl: Int64 = 0

  public var source: String = String()

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var userID: String {
    get {return _userID ?? String()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var remoteID: String {
    get {return _remoteID ?? String()}
    set {_remoteID = newValue}
  }
  /// Returns true if `remoteID` has been explicitly set.
  public var hasRemoteID: Bool {return self._remoteID != nil}
  /// Clears the value of `remoteID`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteID() {self._remoteID = nil}

  public var remoteName: String {
    get {return _remoteName ?? String()}
    set {_remoteName = newValue}
  }
  /// Returns true if `remoteName` has been explicitly set.
  public var hasRemoteName: Bool {return self._remoteName != nil}
  /// Clears the value of `remoteName`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteName() {self._remoteName = nil}

  public var info: PBMapping {
    get {return _info ?? PBMapping()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _userID: String? = nil
  fileprivate var _remoteID: String? = nil
  fileprivate var _remoteName: String? = nil
  fileprivate var _info: PBMapping? = nil
}

public struct PBContactList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contacts: [PBContact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var messages: [PBMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
}

public struct PBChatIDList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chats: [PBGUID] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBPing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBPong {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBHistoryQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatGuid: PBGUID {
    get {return _chatGuid ?? PBGUID()}
    set {_chatGuid = newValue}
  }
  /// Returns true if `chatGuid` has been explicitly set.
  public var hasChatGuid: Bool {return self._chatGuid != nil}
  /// Clears the value of `chatGuid`. Subsequent reads from it will return its default value.
  public mutating func clearChatGuid() {self._chatGuid = nil}

  public var beforeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _beforeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_beforeDate = newValue}
  }
  /// Returns true if `beforeDate` has been explicitly set.
  public var hasBeforeDate: Bool {return self._beforeDate != nil}
  /// Clears the value of `beforeDate`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeDate() {self._beforeDate = nil}

  public var afterDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _afterDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_afterDate = newValue}
  }
  /// Returns true if `afterDate` has been explicitly set.
  public var hasAfterDate: Bool {return self._afterDate != nil}
  /// Clears the value of `afterDate`. Subsequent reads from it will return its default value.
  public mutating func clearAfterDate() {self._afterDate = nil}

  public var beforeGuid: String {
    get {return _beforeGuid ?? String()}
    set {_beforeGuid = newValue}
  }
  /// Returns true if `beforeGuid` has been explicitly set.
  public var hasBeforeGuid: Bool {return self._beforeGuid != nil}
  /// Clears the value of `beforeGuid`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeGuid() {self._beforeGuid = nil}

  public var afterGuid: String {
    get {return _afterGuid ?? String()}
    set {_afterGuid = newValue}
  }
  /// Returns true if `afterGuid` has been explicitly set.
  public var hasAfterGuid: Bool {return self._afterGuid != nil}
  /// Clears the value of `afterGuid`. Subsequent reads from it will return its default value.
  public mutating func clearAfterGuid() {self._afterGuid = nil}

  public var limit: Int64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatGuid: PBGUID? = nil
  fileprivate var _beforeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _afterDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _beforeGuid: String? = nil
  fileprivate var _afterGuid: String? = nil
  fileprivate var _limit: Int64? = nil
}

public struct PBChatQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messagesAfterDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _messagesAfterDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_messagesAfterDate = newValue}
  }
  /// Returns true if `messagesAfterDate` has been explicitly set.
  public var hasMessagesAfterDate: Bool {return self._messagesAfterDate != nil}
  /// Clears the value of `messagesAfterDate`. Subsequent reads from it will return its default value.
  public mutating func clearMessagesAfterDate() {self._messagesAfterDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messagesAfterDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct PBEmpty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBEmptyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: PBEmptyResult.OneOf_Result? = nil

  public var empty: PBEmpty {
    get {
      if case .empty(let v)? = result {return v}
      return PBEmpty()
    }
    set {result = .empty(newValue)}
  }

  public var error: PBError {
    get {
      if case .error(let v)? = result {return v}
      return PBError()
    }
    set {result = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case empty(PBEmpty)
    case error(PBError)

  #if !swift(>=4.1)
    public static func ==(lhs: PBEmptyResult.OneOf_Result, rhs: PBEmptyResult.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBBarcelonaStartupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var socketPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var isResponse: Bool = false

  public var command: PBPayload.OneOf_Command? = nil

  /// To Mautrix
  public var message: PBMessage {
    get {
      if case .message(let v)? = command {return v}
      return PBMessage()
    }
    set {command = .message(newValue)}
  }

  public var readReceipt: PBReadReceipt {
    get {
      if case .readReceipt(let v)? = command {return v}
      return PBReadReceipt()
    }
    set {command = .readReceipt(newValue)}
  }

  public var typingNotification: PBTypingNotification {
    get {
      if case .typingNotification(let v)? = command {return v}
      return PBTypingNotification()
    }
    set {command = .typingNotification(newValue)}
  }

  public var chat: PBChatInfo {
    get {
      if case .chat(let v)? = command {return v}
      return PBChatInfo()
    }
    set {command = .chat(newValue)}
  }

  public var bridgeStatus: PBBridgeStatus {
    get {
      if case .bridgeStatus(let v)? = command {return v}
      return PBBridgeStatus()
    }
    set {command = .bridgeStatus(newValue)}
  }

  public var contact: PBContact {
    get {
      if case .contact(let v)? = command {return v}
      return PBContact()
    }
    set {command = .contact(newValue)}
  }

  public var sendMessageStatus: PBSendMessageStatus {
    get {
      if case .sendMessageStatus(let v)? = command {return v}
      return PBSendMessageStatus()
    }
    set {command = .sendMessageStatus(newValue)}
  }

  public var log: PBLogLine {
    get {
      if case .log(let v)? = command {return v}
      return PBLogLine()
    }
    set {command = .log(newValue)}
  }

  public var contacts: PBContactList {
    get {
      if case .contacts(let v)? = command {return v}
      return PBContactList()
    }
    set {command = .contacts(newValue)}
  }

  public var error: PBError {
    get {
      if case .error(let v)? = command {return v}
      return PBError()
    }
    set {command = .error(newValue)}
  }

  public var ack: Bool {
    get {
      if case .ack(let v)? = command {return v}
      return false
    }
    set {command = .ack(newValue)}
  }

  /// To Barcelona
  public var sendMessage: PBSendMessageRequest {
    get {
      if case .sendMessage(let v)? = command {return v}
      return PBSendMessageRequest()
    }
    set {command = .sendMessage(newValue)}
  }

  public var sendReadReceipt: PBSendReadReceiptRequest {
    get {
      if case .sendReadReceipt(let v)? = command {return v}
      return PBSendReadReceiptRequest()
    }
    set {command = .sendReadReceipt(newValue)}
  }

  public var setTyping: PBSetTypingRequest {
    get {
      if case .setTyping(let v)? = command {return v}
      return PBSetTypingRequest()
    }
    set {command = .setTyping(newValue)}
  }

  public var getChats: PBGetChatsRequest {
    get {
      if case .getChats(let v)? = command {return v}
      return PBGetChatsRequest()
    }
    set {command = .getChats(newValue)}
  }

  public var getChat: PBGetChatRequest {
    get {
      if case .getChat(let v)? = command {return v}
      return PBGetChatRequest()
    }
    set {command = .getChat(newValue)}
  }

  public var getChatAvatar: PBGetChatAvatarRequest {
    get {
      if case .getChatAvatar(let v)? = command {return v}
      return PBGetChatAvatarRequest()
    }
    set {command = .getChatAvatar(newValue)}
  }

  public var getContact: PBGetContactRequest {
    get {
      if case .getContact(let v)? = command {return v}
      return PBGetContactRequest()
    }
    set {command = .getContact(newValue)}
  }

  public var getContactList: Bool {
    get {
      if case .getContactList(let v)? = command {return v}
      return false
    }
    set {command = .getContactList(newValue)}
  }

  public var getMessagesAfter: PBGetMessagesAfterRequest {
    get {
      if case .getMessagesAfter(let v)? = command {return v}
      return PBGetMessagesAfterRequest()
    }
    set {command = .getMessagesAfter(newValue)}
  }

  public var preStartupSync: Bool {
    get {
      if case .preStartupSync(let v)? = command {return v}
      return false
    }
    set {command = .preStartupSync(newValue)}
  }

  public var resolveIdentifier: PBResolveIdentifierRequest {
    get {
      if case .resolveIdentifier(let v)? = command {return v}
      return PBResolveIdentifierRequest()
    }
    set {command = .resolveIdentifier(newValue)}
  }

  public var prepareDm: PBPrepareDMRequest {
    get {
      if case .prepareDm(let v)? = command {return v}
      return PBPrepareDMRequest()
    }
    set {command = .prepareDm(newValue)}
  }

  public var ping: PBPing {
    get {
      if case .ping(let v)? = command {return v}
      return PBPing()
    }
    set {command = .ping(newValue)}
  }

  public var pong: PBPong {
    get {
      if case .pong(let v)? = command {return v}
      return PBPong()
    }
    set {command = .pong(newValue)}
  }

  public var messages: PBMessageList {
    get {
      if case .messages(let v)? = command {return v}
      return PBMessageList()
    }
    set {command = .messages(newValue)}
  }

  public var getRecentMessages: PBGetRecentMessagesRequest {
    get {
      if case .getRecentMessages(let v)? = command {return v}
      return PBGetRecentMessagesRequest()
    }
    set {command = .getRecentMessages(newValue)}
  }

  public var chatList: PBChatIDList {
    get {
      if case .chatList(let v)? = command {return v}
      return PBChatIDList()
    }
    set {command = .chatList(newValue)}
  }

  public var attachment: PBAttachment {
    get {
      if case .attachment(let v)? = command {return v}
      return PBAttachment()
    }
    set {command = .attachment(newValue)}
  }

  public var sendResponse: PBSendResponse {
    get {
      if case .sendResponse(let v)? = command {return v}
      return PBSendResponse()
    }
    set {command = .sendResponse(newValue)}
  }

  public var syncHookResponse: PBStartupSyncHookResponse {
    get {
      if case .syncHookResponse(let v)? = command {return v}
      return PBStartupSyncHookResponse()
    }
    set {command = .syncHookResponse(newValue)}
  }

  public var resolveIdentifierResponse: PBResolveIdentifierResponse {
    get {
      if case .resolveIdentifierResponse(let v)? = command {return v}
      return PBResolveIdentifierResponse()
    }
    set {command = .resolveIdentifierResponse(newValue)}
  }

  public var null: Bool {
    get {
      if case .null(let v)? = command {return v}
      return false
    }
    set {command = .null(newValue)}
  }

  public var guid: PBGUID {
    get {
      if case .guid(let v)? = command {return v}
      return PBGUID()
    }
    set {command = .guid(newValue)}
  }

  public var historyQuery: PBHistoryQuery {
    get {
      if case .historyQuery(let v)? = command {return v}
      return PBHistoryQuery()
    }
    set {command = .historyQuery(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Command: Equatable {
    /// To Mautrix
    case message(PBMessage)
    case readReceipt(PBReadReceipt)
    case typingNotification(PBTypingNotification)
    case chat(PBChatInfo)
    case bridgeStatus(PBBridgeStatus)
    case contact(PBContact)
    case sendMessageStatus(PBSendMessageStatus)
    case log(PBLogLine)
    case contacts(PBContactList)
    case error(PBError)
    case ack(Bool)
    /// To Barcelona
    case sendMessage(PBSendMessageRequest)
    case sendReadReceipt(PBSendReadReceiptRequest)
    case setTyping(PBSetTypingRequest)
    case getChats(PBGetChatsRequest)
    case getChat(PBGetChatRequest)
    case getChatAvatar(PBGetChatAvatarRequest)
    case getContact(PBGetContactRequest)
    case getContactList(Bool)
    case getMessagesAfter(PBGetMessagesAfterRequest)
    case preStartupSync(Bool)
    case resolveIdentifier(PBResolveIdentifierRequest)
    case prepareDm(PBPrepareDMRequest)
    case ping(PBPing)
    case pong(PBPong)
    case messages(PBMessageList)
    case getRecentMessages(PBGetRecentMessagesRequest)
    case chatList(PBChatIDList)
    case attachment(PBAttachment)
    case sendResponse(PBSendResponse)
    case syncHookResponse(PBStartupSyncHookResponse)
    case resolveIdentifierResponse(PBResolveIdentifierResponse)
    case null(Bool)
    case guid(PBGUID)
    case historyQuery(PBHistoryQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: PBPayload.OneOf_Command, rhs: PBPayload.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.message, .message): return {
        guard case .message(let l) = lhs, case .message(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readReceipt, .readReceipt): return {
        guard case .readReceipt(let l) = lhs, case .readReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typingNotification, .typingNotification): return {
        guard case .typingNotification(let l) = lhs, case .typingNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chat, .chat): return {
        guard case .chat(let l) = lhs, case .chat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bridgeStatus, .bridgeStatus): return {
        guard case .bridgeStatus(let l) = lhs, case .bridgeStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contact, .contact): return {
        guard case .contact(let l) = lhs, case .contact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendMessageStatus, .sendMessageStatus): return {
        guard case .sendMessageStatus(let l) = lhs, case .sendMessageStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.log, .log): return {
        guard case .log(let l) = lhs, case .log(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contacts, .contacts): return {
        guard case .contacts(let l) = lhs, case .contacts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendMessage, .sendMessage): return {
        guard case .sendMessage(let l) = lhs, case .sendMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendReadReceipt, .sendReadReceipt): return {
        guard case .sendReadReceipt(let l) = lhs, case .sendReadReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTyping, .setTyping): return {
        guard case .setTyping(let l) = lhs, case .setTyping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChats, .getChats): return {
        guard case .getChats(let l) = lhs, case .getChats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChat, .getChat): return {
        guard case .getChat(let l) = lhs, case .getChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChatAvatar, .getChatAvatar): return {
        guard case .getChatAvatar(let l) = lhs, case .getChatAvatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getContact, .getContact): return {
        guard case .getContact(let l) = lhs, case .getContact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getContactList, .getContactList): return {
        guard case .getContactList(let l) = lhs, case .getContactList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getMessagesAfter, .getMessagesAfter): return {
        guard case .getMessagesAfter(let l) = lhs, case .getMessagesAfter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preStartupSync, .preStartupSync): return {
        guard case .preStartupSync(let l) = lhs, case .preStartupSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resolveIdentifier, .resolveIdentifier): return {
        guard case .resolveIdentifier(let l) = lhs, case .resolveIdentifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prepareDm, .prepareDm): return {
        guard case .prepareDm(let l) = lhs, case .prepareDm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messages, .messages): return {
        guard case .messages(let l) = lhs, case .messages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getRecentMessages, .getRecentMessages): return {
        guard case .getRecentMessages(let l) = lhs, case .getRecentMessages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatList, .chatList): return {
        guard case .chatList(let l) = lhs, case .chatList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attachment, .attachment): return {
        guard case .attachment(let l) = lhs, case .attachment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendResponse, .sendResponse): return {
        guard case .sendResponse(let l) = lhs, case .sendResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.syncHookResponse, .syncHookResponse): return {
        guard case .syncHookResponse(let l) = lhs, case .syncHookResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resolveIdentifierResponse, .resolveIdentifierResponse): return {
        guard case .resolveIdentifierResponse(let l) = lhs, case .resolveIdentifierResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.null, .null): return {
        guard case .null(let l) = lhs, case .null(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guid, .guid): return {
        guard case .guid(let l) = lhs, case .guid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyQuery, .historyQuery): return {
        guard case .historyQuery(let l) = lhs, case .historyQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PBTapbackType: @unchecked Sendable {}
extension PBItemType: @unchecked Sendable {}
extension PBGroupActionType: @unchecked Sendable {}
extension PBGUID: @unchecked Sendable {}
extension PBMessageTarget: @unchecked Sendable {}
extension PBTapback: @unchecked Sendable {}
extension PBAttachment: @unchecked Sendable {}
extension PBRichLinkAssetSource: @unchecked Sendable {}
extension PBRichLinkAssetSource.OneOf_Source: @unchecked Sendable {}
extension PBRichLinkAssetSize: @unchecked Sendable {}
extension PBRichLinkAsset: @unchecked Sendable {}
extension PBRichLinkVideoAsset: @unchecked Sendable {}
extension PBRichLink: @unchecked Sendable {}
extension PBArray: @unchecked Sendable {}
extension PBMapping: @unchecked Sendable {}
extension PBMetadataValue: @unchecked Sendable {}
extension PBMetadataValue.OneOf_Value: @unchecked Sendable {}
extension PBCorrelations: @unchecked Sendable {}
extension PBTextItem: @unchecked Sendable {}
extension PBAttachmentItem: @unchecked Sendable {}
extension PBTypingItem: @unchecked Sendable {}
extension PBPluginItem: @unchecked Sendable {}
extension PBGroupNameChangeItem: @unchecked Sendable {}
extension PBGroupAvatarChangeItem: @unchecked Sendable {}
extension PBGroupParticipantChangeItem: @unchecked Sendable {}
extension PBTapbackItem: @unchecked Sendable {}
extension PBPhantomItem: @unchecked Sendable {}
extension PBItem: @unchecked Sendable {}
extension PBItem.OneOf__: @unchecked Sendable {}
extension PBMessage: @unchecked Sendable {}
extension PBReadReceipt: @unchecked Sendable {}
extension PBTypingNotification: @unchecked Sendable {}
extension PBContact: @unchecked Sendable {}
extension PBChatInfo: @unchecked Sendable {}
extension PBSendResponse: @unchecked Sendable {}
extension PBSendResult: @unchecked Sendable {}
extension PBSendResult.OneOf_Result: @unchecked Sendable {}
extension PBError: @unchecked Sendable {}
extension PBSendMessageStatus: @unchecked Sendable {}
extension PBStartupSyncHookResponse: @unchecked Sendable {}
extension PBSendTextMessageRequest: @unchecked Sendable {}
extension PBSendMediaMessageRequest: @unchecked Sendable {}
extension PBSendTapbackMessageRequest: @unchecked Sendable {}
extension PBSendMessagePart: @unchecked Sendable {}
extension PBSendMessagePart.OneOf_Part: @unchecked Sendable {}
extension PBSendMessageRequest: @unchecked Sendable {}
extension PBSendReadReceiptRequest: @unchecked Sendable {}
extension PBSetTypingRequest: @unchecked Sendable {}
extension PBGetChatRequest: @unchecked Sendable {}
extension PBGetChatAvatarRequest: @unchecked Sendable {}
extension PBGetChatsRequest: @unchecked Sendable {}
extension PBGetContactRequest: @unchecked Sendable {}
extension PBGetRecentMessagesRequest: @unchecked Sendable {}
extension PBGetMessagesAfterRequest: @unchecked Sendable {}
extension PBResolveIdentifierRequest: @unchecked Sendable {}
extension PBResolveIdentifierResponse: @unchecked Sendable {}
extension PBResolveIdentifierResult: @unchecked Sendable {}
extension PBResolveIdentifierResult.OneOf_Result: @unchecked Sendable {}
extension PBPrepareDMRequest: @unchecked Sendable {}
extension PBLogLine: @unchecked Sendable {}
extension PBBridgeStatus: @unchecked Sendable {}
extension PBContactList: @unchecked Sendable {}
extension PBMessageList: @unchecked Sendable {}
extension PBChatIDList: @unchecked Sendable {}
extension PBPing: @unchecked Sendable {}
extension PBPong: @unchecked Sendable {}
extension PBHistoryQuery: @unchecked Sendable {}
extension PBChatQuery: @unchecked Sendable {}
extension PBEmpty: @unchecked Sendable {}
extension PBEmptyResult: @unchecked Sendable {}
extension PBEmptyResult.OneOf_Result: @unchecked Sendable {}
extension PBBarcelonaStartupInfo: @unchecked Sendable {}
extension PBPayload: @unchecked Sendable {}
extension PBPayload.OneOf_Command: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PBTapbackType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TapbackNothing"),
    2000: .same(proto: "TapbackLove"),
    2001: .same(proto: "TapbackLike"),
    2002: .same(proto: "TapbackDislike"),
    2003: .same(proto: "TapbackLaugh"),
    2004: .same(proto: "TapbackEmphasis"),
    2005: .same(proto: "TapbackQuestion"),
    3000: .same(proto: "TapbackRemoveLove"),
    3001: .same(proto: "TapbackRemoveLike"),
    3002: .same(proto: "TapbackRemoveDislike"),
    3003: .same(proto: "TapbackRemoveLaugh"),
    3004: .same(proto: "TapbackRemoveEmphasis"),
    3005: .same(proto: "TapbackRemoveQuestion"),
  ]
}

extension PBItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ItemTypeMessage"),
    1: .same(proto: "ItemTypeMember"),
    2: .same(proto: "ItemTypeName"),
    4: .same(proto: "ItemTypeAvatar"),
    5: .same(proto: "ItemTypeError"),
  ]
}

extension PBGroupActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GroupActionAdd"),
    1: .same(proto: "GroupActionRemove"),
  ]
}

extension PBGUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GUID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Service"),
    2: .same(proto: "IsGroup"),
    3: .same(proto: "LocalID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGroup) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.localID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if self.isGroup != false {
      try visitor.visitSingularBoolField(value: self.isGroup, fieldNumber: 2)
    }
    if !self.localID.isEmpty {
      try visitor.visitSingularStringField(value: self.localID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGUID, rhs: PBGUID) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.isGroup != rhs.isGroup {return false}
    if lhs.localID != rhs.localID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBMessageTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "Part"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.guid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.part) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    if self.part != 0 {
      try visitor.visitSingularInt64Field(value: self.part, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBMessageTarget, rhs: PBMessageTarget) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs.part != rhs.part {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTapback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Tapback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Target"),
    2: .same(proto: "Type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if self.type != .tapbackNothing {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBTapback, rhs: PBTapback) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Attachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "PathOnDisk"),
    3: .same(proto: "FileName"),
    4: .same(proto: "MimeType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pathOnDisk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.pathOnDisk.isEmpty {
      try visitor.visitSingularStringField(value: self.pathOnDisk, fieldNumber: 2)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 3)
    }
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBAttachment, rhs: PBAttachment) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.pathOnDisk != rhs.pathOnDisk {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRichLinkAssetSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RichLinkAssetSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "URL"),
    2: .same(proto: "Data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .url(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.source {
    case .url?: try {
      guard case .url(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBRichLinkAssetSource, rhs: PBRichLinkAssetSource) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRichLinkAssetSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RichLinkAssetSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Width"),
    2: .same(proto: "Height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBRichLinkAssetSize, rhs: PBRichLinkAssetSize) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRichLinkAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RichLinkAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MimeType"),
    2: .same(proto: "AccessibilityText"),
    3: .same(proto: "Source"),
    4: .same(proto: "OriginalURL"),
    5: .same(proto: "Size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._accessibilityText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._originalURL) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessibilityText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originalURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBRichLinkAsset, rhs: PBRichLinkAsset) -> Bool {
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._accessibilityText != rhs._accessibilityText {return false}
    if lhs._source != rhs._source {return false}
    if lhs._originalURL != rhs._originalURL {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRichLinkVideoAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RichLinkVideoAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HasAudio"),
    2: .same(proto: "YouTubeURL"),
    3: .same(proto: "StreamingURL"),
    4: .same(proto: "Asset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasAudio_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._youTubeURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._streamingURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.hasAudio_p != false {
      try visitor.visitSingularBoolField(value: self.hasAudio_p, fieldNumber: 1)
    }
    try { if let v = self._youTubeURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._streamingURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBRichLinkVideoAsset, rhs: PBRichLinkVideoAsset) -> Bool {
    if lhs.hasAudio_p != rhs.hasAudio_p {return false}
    if lhs._youTubeURL != rhs._youTubeURL {return false}
    if lhs._streamingURL != rhs._streamingURL {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRichLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RichLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OriginalURL"),
    2: .same(proto: "URL"),
    3: .same(proto: "Title"),
    4: .same(proto: "Summary"),
    5: .same(proto: "SelectedText"),
    6: .same(proto: "SiteName"),
    7: .same(proto: "RelatedURL"),
    8: .same(proto: "Creator"),
    9: .same(proto: "CreatorFacebookProfile"),
    10: .same(proto: "CreatorTwitterUsername"),
    11: .same(proto: "ItemType"),
    12: .same(proto: "Icon"),
    13: .same(proto: "Image"),
    14: .same(proto: "Video"),
    19: .same(proto: "Audio"),
    15: .same(proto: "Images"),
    16: .same(proto: "Videos"),
    17: .same(proto: "StreamingVideos"),
    18: .same(proto: "Audios"),
  ]

  fileprivate class _StorageClass {
    var _originalURL: String? = nil
    var _url: String? = nil
    var _title: String? = nil
    var _summary: String? = nil
    var _selectedText: String? = nil
    var _siteName: String? = nil
    var _relatedURL: String? = nil
    var _creator: String? = nil
    var _creatorFacebookProfile: String? = nil
    var _creatorTwitterUsername: String? = nil
    var _itemType: String? = nil
    var _icon: PBRichLinkAsset? = nil
    var _image: PBRichLinkAsset? = nil
    var _video: PBRichLinkVideoAsset? = nil
    var _audio: PBRichLinkAsset? = nil
    var _images: [PBRichLinkAsset] = []
    var _videos: [PBRichLinkAsset] = []
    var _streamingVideos: [PBRichLinkAsset] = []
    var _audios: [PBRichLinkAsset] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _originalURL = source._originalURL
      _url = source._url
      _title = source._title
      _summary = source._summary
      _selectedText = source._selectedText
      _siteName = source._siteName
      _relatedURL = source._relatedURL
      _creator = source._creator
      _creatorFacebookProfile = source._creatorFacebookProfile
      _creatorTwitterUsername = source._creatorTwitterUsername
      _itemType = source._itemType
      _icon = source._icon
      _image = source._image
      _video = source._video
      _audio = source._audio
      _images = source._images
      _videos = source._videos
      _streamingVideos = source._streamingVideos
      _audios = source._audios
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._originalURL) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._selectedText) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._siteName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._relatedURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._creatorFacebookProfile) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._creatorTwitterUsername) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._itemType) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._icon) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._video) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._images) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._videos) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._streamingVideos) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._audios) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._originalURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._summary {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._selectedText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._siteName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._relatedURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._creator {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._creatorFacebookProfile {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._creatorTwitterUsername {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._itemType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._icon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._video {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._images, fieldNumber: 15)
      }
      if !_storage._videos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._videos, fieldNumber: 16)
      }
      if !_storage._streamingVideos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._streamingVideos, fieldNumber: 17)
      }
      if !_storage._audios.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._audios, fieldNumber: 18)
      }
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBRichLink, rhs: PBRichLink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._originalURL != rhs_storage._originalURL {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._selectedText != rhs_storage._selectedText {return false}
        if _storage._siteName != rhs_storage._siteName {return false}
        if _storage._relatedURL != rhs_storage._relatedURL {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._creatorFacebookProfile != rhs_storage._creatorFacebookProfile {return false}
        if _storage._creatorTwitterUsername != rhs_storage._creatorTwitterUsername {return false}
        if _storage._itemType != rhs_storage._itemType {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._videos != rhs_storage._videos {return false}
        if _storage._streamingVideos != rhs_storage._streamingVideos {return false}
        if _storage._audios != rhs_storage._audios {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Array"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBArray, rhs: PBArray) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Mapping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mapping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBMetadataValue>.self, value: &self.mapping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBMetadataValue>.self, value: self.mapping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBMapping, rhs: PBMapping) -> Bool {
    if lhs.mapping != rhs.mapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBMetadataValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MetadataValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "String"),
    2: .same(proto: "Double"),
    3: .same(proto: "Float"),
    4: .same(proto: "Int32"),
    5: .same(proto: "Int64"),
    6: .same(proto: "UInt32"),
    7: .same(proto: "UInt64"),
    8: .same(proto: "SInt32"),
    9: .same(proto: "SInt64"),
    10: .same(proto: "Fixed32"),
    11: .same(proto: "Fixed64"),
    12: .same(proto: "SFIxed32"),
    13: .same(proto: "SFixed64"),
    14: .same(proto: "Bool"),
    15: .same(proto: "Bytes"),
    16: .same(proto: "Array"),
    17: .same(proto: "Mapping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 2: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .double(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .float(v)
        }
      }()
      case 4: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .int32(v)
        }
      }()
      case 5: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .int64(v)
        }
      }()
      case 6: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .uint32(v)
        }
      }()
      case 7: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .uint64(v)
        }
      }()
      case 8: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .sint32(v)
        }
      }()
      case 9: try {
        var v: Int64?
        try decoder.decodeSingularSInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .sint64(v)
        }
      }()
      case 10: try {
        var v: UInt32?
        try decoder.decodeSingularFixed32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .fixed32(v)
        }
      }()
      case 11: try {
        var v: UInt64?
        try decoder.decodeSingularFixed64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .fixed64(v)
        }
      }()
      case 12: try {
        var v: Int32?
        try decoder.decodeSingularSFixed32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .sfixed32(v)
        }
      }()
      case 13: try {
        var v: Int64?
        try decoder.decodeSingularSFixed64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .sfixed64(v)
        }
      }()
      case 14: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .bool(v)
        }
      }()
      case 15: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .bytes(v)
        }
      }()
      case 16: try {
        var v: PBArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .array(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .array(v)
        }
      }()
      case 17: try {
        var v: PBMapping?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .mapping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .mapping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .double?: try {
      guard case .double(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .float?: try {
      guard case .float(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case .int32?: try {
      guard case .int32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }()
    case .int64?: try {
      guard case .int64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }()
    case .uint32?: try {
      guard case .uint32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }()
    case .uint64?: try {
      guard case .uint64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }()
    case .sint32?: try {
      guard case .sint32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 8)
    }()
    case .sint64?: try {
      guard case .sint64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 9)
    }()
    case .fixed32?: try {
      guard case .fixed32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    }()
    case .fixed64?: try {
      guard case .fixed64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 11)
    }()
    case .sfixed32?: try {
      guard case .sfixed32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 12)
    }()
    case .sfixed64?: try {
      guard case .sfixed64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 13)
    }()
    case .bool?: try {
      guard case .bool(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
    }()
    case .array?: try {
      guard case .array(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mapping?: try {
      guard case .mapping(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBMetadataValue, rhs: PBMetadataValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCorrelations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Correlations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sender"),
    2: .same(proto: "Chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._chat {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBCorrelations, rhs: PBCorrelations) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TextItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Text"),
    2: .same(proto: "Subject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBTextItem, rhs: PBTextItem) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAttachmentItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AttachmentItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Attachment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBAttachmentItem, rhs: PBAttachmentItem) -> Bool {
    if lhs._attachment != rhs._attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTypingItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TypingItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.typing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.typing != false {
      try visitor.visitSingularBoolField(value: self.typing, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBTypingItem, rhs: PBTypingItem) -> Bool {
    if lhs.typing != rhs.typing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPluginItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PluginItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RichLink"),
    2: .same(proto: "Attachments"),
    3: .same(proto: "FallbackText"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._richLink) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._fallbackText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._richLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 2)
    }
    try { if let v = self._fallbackText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPluginItem, rhs: PBPluginItem) -> Bool {
    if lhs._richLink != rhs._richLink {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs._fallbackText != rhs._fallbackText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGroupNameChangeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GroupNameChangeItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGroupNameChangeItem, rhs: PBGroupNameChangeItem) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGroupAvatarChangeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GroupAvatarChangeItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Action"),
    2: .same(proto: "NewAvatar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newAvatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .groupActionAdd {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try { if let v = self._newAvatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGroupAvatarChangeItem, rhs: PBGroupAvatarChangeItem) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs._newAvatar != rhs._newAvatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGroupParticipantChangeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GroupParticipantChangeItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Action"),
    2: .same(proto: "Target"),
    3: .same(proto: "Initiator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._initiator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .groupActionAdd {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._initiator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGroupParticipantChangeItem, rhs: PBGroupParticipantChangeItem) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs._target != rhs._target {return false}
    if lhs._initiator != rhs._initiator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTapbackItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TapbackItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Tapback"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tapback) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tapback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBTapbackItem, rhs: PBTapbackItem) -> Bool {
    if lhs._tapback != rhs._tapback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPhantomItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PhantomItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TypeString"),
    2: .same(proto: "DebugDescription"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.typeString) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.debugDescription_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeString.isEmpty {
      try visitor.visitSingularStringField(value: self.typeString, fieldNumber: 1)
    }
    if !self.debugDescription_p.isEmpty {
      try visitor.visitSingularStringField(value: self.debugDescription_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPhantomItem, rhs: PBPhantomItem) -> Bool {
    if lhs.typeString != rhs.typeString {return false}
    if lhs.debugDescription_p != rhs.debugDescription_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    25: .same(proto: "Text"),
    26: .same(proto: "Attachment"),
    27: .same(proto: "Typing"),
    28: .same(proto: "Plugin"),
    29: .same(proto: "GroupNameChange"),
    30: .same(proto: "GroupAvatarChange"),
    31: .same(proto: "GroupParticipantChange"),
    32: .same(proto: "Tapback"),
    33: .same(proto: "Phantom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.guid) }()
      case 25: try {
        var v: PBTextItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .text(v)
        }
      }()
      case 26: try {
        var v: PBAttachmentItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .attachment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .attachment(v)
        }
      }()
      case 27: try {
        var v: PBTypingItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .typing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .typing(v)
        }
      }()
      case 28: try {
        var v: PBPluginItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .plugin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .plugin(v)
        }
      }()
      case 29: try {
        var v: PBGroupNameChangeItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .groupNameChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .groupNameChange(v)
        }
      }()
      case 30: try {
        var v: PBGroupAvatarChangeItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .groupAvatarChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .groupAvatarChange(v)
        }
      }()
      case 31: try {
        var v: PBGroupParticipantChangeItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .groupParticipantChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .groupParticipantChange(v)
        }
      }()
      case 32: try {
        var v: PBTapbackItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .tapback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .tapback(v)
        }
      }()
      case 33: try {
        var v: PBPhantomItem?
        var hadOneofValue = false
        if let current = self.___ {
          hadOneofValue = true
          if case .phantom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.___ = .phantom(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    switch self.___ {
    case .text?: try {
      guard case .text(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .attachment?: try {
      guard case .attachment(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .typing?: try {
      guard case .typing(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .plugin?: try {
      guard case .plugin(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .groupNameChange?: try {
      guard case .groupNameChange(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .groupAvatarChange?: try {
      guard case .groupAvatarChange(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .groupParticipantChange?: try {
      guard case .groupParticipantChange(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .tapback?: try {
      guard case .tapback(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .phantom?: try {
      guard case .phantom(let v)? = self.___ else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBItem, rhs: PBItem) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs.___ != rhs.___ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "Time"),
    5: .same(proto: "ChatGUID"),
    6: .same(proto: "Sender"),
    8: .same(proto: "IsFromMe"),
    9: .same(proto: "IsRead"),
    10: .same(proto: "ReadAt"),
    11: .same(proto: "IsDelivered"),
    12: .same(proto: "IsSent"),
    14: .same(proto: "IsAudioMessage"),
    15: .same(proto: "ThreadTarget"),
    18: .same(proto: "ErrorNotice"),
    23: .same(proto: "MessageMetadata"),
    24: .same(proto: "Correlations"),
    25: .same(proto: "Service"),
    26: .same(proto: "Items"),
  ]

  fileprivate class _StorageClass {
    var _guid: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _chatGuid: PBGUID? = nil
    var _sender: PBGUID? = nil
    var _isFromMe: Bool = false
    var _isRead: Bool = false
    var _readAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isDelivered: Bool = false
    var _isSent: Bool = false
    var _isAudioMessage: Bool = false
    var _threadTarget: PBMessageTarget? = nil
    var _errorNotice: String? = nil
    var _messageMetadata: PBMapping? = nil
    var _correlations: PBCorrelations? = nil
    var _service: String = String()
    var _items: [PBItem] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _guid = source._guid
      _time = source._time
      _chatGuid = source._chatGuid
      _sender = source._sender
      _isFromMe = source._isFromMe
      _isRead = source._isRead
      _readAt = source._readAt
      _isDelivered = source._isDelivered
      _isSent = source._isSent
      _isAudioMessage = source._isAudioMessage
      _threadTarget = source._threadTarget
      _errorNotice = source._errorNotice
      _messageMetadata = source._messageMetadata
      _correlations = source._correlations
      _service = source._service
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._guid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._chatGuid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sender) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isFromMe) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isRead) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._readAt) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isDelivered) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._isSent) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isAudioMessage) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._threadTarget) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._errorNotice) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._messageMetadata) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._correlations) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._service) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._items) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._guid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._guid, fieldNumber: 1)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chatGuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._isFromMe != false {
        try visitor.visitSingularBoolField(value: _storage._isFromMe, fieldNumber: 8)
      }
      if _storage._isRead != false {
        try visitor.visitSingularBoolField(value: _storage._isRead, fieldNumber: 9)
      }
      try { if let v = _storage._readAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._isDelivered != false {
        try visitor.visitSingularBoolField(value: _storage._isDelivered, fieldNumber: 11)
      }
      if _storage._isSent != false {
        try visitor.visitSingularBoolField(value: _storage._isSent, fieldNumber: 12)
      }
      if _storage._isAudioMessage != false {
        try visitor.visitSingularBoolField(value: _storage._isAudioMessage, fieldNumber: 14)
      }
      try { if let v = _storage._threadTarget {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._errorNotice {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._messageMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._correlations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._service.isEmpty {
        try visitor.visitSingularStringField(value: _storage._service, fieldNumber: 25)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBMessage, rhs: PBMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._guid != rhs_storage._guid {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._chatGuid != rhs_storage._chatGuid {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._isFromMe != rhs_storage._isFromMe {return false}
        if _storage._isRead != rhs_storage._isRead {return false}
        if _storage._readAt != rhs_storage._readAt {return false}
        if _storage._isDelivered != rhs_storage._isDelivered {return false}
        if _storage._isSent != rhs_storage._isSent {return false}
        if _storage._isAudioMessage != rhs_storage._isAudioMessage {return false}
        if _storage._threadTarget != rhs_storage._threadTarget {return false}
        if _storage._errorNotice != rhs_storage._errorNotice {return false}
        if _storage._messageMetadata != rhs_storage._messageMetadata {return false}
        if _storage._correlations != rhs_storage._correlations {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBReadReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReadReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SenderGUID"),
    2: .same(proto: "IsFromMe"),
    3: .same(proto: "ChatGUID"),
    4: .same(proto: "ReadUpTo"),
    5: .same(proto: "ReadAt"),
    6: .same(proto: "Correlations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderGuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFromMe) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.readUpTo) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._readAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._correlations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isFromMe != false {
      try visitor.visitSingularBoolField(value: self.isFromMe, fieldNumber: 2)
    }
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.readUpTo.isEmpty {
      try visitor.visitSingularStringField(value: self.readUpTo, fieldNumber: 4)
    }
    try { if let v = self._readAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._correlations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBReadReceipt, rhs: PBReadReceipt) -> Bool {
    if lhs._senderGuid != rhs._senderGuid {return false}
    if lhs.isFromMe != rhs.isFromMe {return false}
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.readUpTo != rhs.readUpTo {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs._correlations != rhs._correlations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTypingNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TypingNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "Typing"),
    3: .same(proto: "Correlations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.typing) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._correlations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.typing != false {
      try visitor.visitSingularBoolField(value: self.typing, fieldNumber: 2)
    }
    try { if let v = self._correlations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBTypingNotification, rhs: PBTypingNotification) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.typing != rhs.typing {return false}
    if lhs._correlations != rhs._correlations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FirstName"),
    2: .same(proto: "LastName"),
    3: .same(proto: "Nickname"),
    4: .same(proto: "Avatar"),
    5: .same(proto: "Phones"),
    6: .same(proto: "Emails"),
    7: .same(proto: "UserGUID"),
    8: .same(proto: "PrimaryIdentifier"),
    9: .same(proto: "CorrelationID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._firstName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lastName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._avatar) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.phones) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.emails) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._userGuid) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._primaryIdentifier) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._correlationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._avatar {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    if !self.phones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.phones, fieldNumber: 5)
    }
    if !self.emails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.emails, fieldNumber: 6)
    }
    try { if let v = self._userGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._primaryIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._correlationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBContact, rhs: PBContact) -> Bool {
    if lhs._firstName != rhs._firstName {return false}
    if lhs._lastName != rhs._lastName {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs.phones != rhs.phones {return false}
    if lhs.emails != rhs.emails {return false}
    if lhs._userGuid != rhs._userGuid {return false}
    if lhs._primaryIdentifier != rhs._primaryIdentifier {return false}
    if lhs._correlationID != rhs._correlationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBChatInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "DisplayName"),
    3: .same(proto: "Members"),
    4: .same(proto: "NoCreateRoom"),
    5: .same(proto: "CorrelationID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._guid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._noCreateRoom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._correlationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._guid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try { if let v = self._noCreateRoom {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._correlationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBChatInfo, rhs: PBChatInfo) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.members != rhs.members {return false}
    if lhs._noCreateRoom != rhs._noCreateRoom {return false}
    if lhs._correlationID != rhs._correlationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "Service"),
    3: .same(proto: "Time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.guid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendResponse, rhs: PBSendResponse) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs.service != rhs.service {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SendResponse"),
    2: .same(proto: "Error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBSendResponse?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .sendResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .sendResponse(v)
        }
      }()
      case 2: try {
        var v: PBError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .sendResponse?: try {
      guard case .sendResponse(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendResult, rhs: PBSendResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Code"),
    2: .same(proto: "Message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBError, rhs: PBError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendMessageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "ChatGUID"),
    3: .same(proto: "Status"),
    4: .same(proto: "Service"),
    5: .same(proto: "Error"),
    6: .same(proto: "Correlations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.guid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._correlations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 3)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 4)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._correlations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendMessageStatus, rhs: PBSendMessageStatus) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.status != rhs.status {return false}
    if lhs.service != rhs.service {return false}
    if lhs._error != rhs._error {return false}
    if lhs._correlations != rhs._correlations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStartupSyncHookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StartupSyncHookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SkipSync"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.skipSync) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.skipSync != false {
      try visitor.visitSingularBoolField(value: self.skipSync, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBStartupSyncHookResponse, rhs: PBStartupSyncHookResponse) -> Bool {
    if lhs.skipSync != rhs.skipSync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendTextMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendTextMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Text"),
    2: .same(proto: "RichLink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._richLink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try { if let v = self._richLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendTextMessageRequest, rhs: PBSendTextMessageRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._richLink != rhs._richLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendMediaMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMediaMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Text"),
    2: .same(proto: "Attachment"),
    3: .same(proto: "IsAudioMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAudioMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isAudioMessage != false {
      try visitor.visitSingularBoolField(value: self.isAudioMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendMediaMessageRequest, rhs: PBSendMediaMessageRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._attachment != rhs._attachment {return false}
    if lhs.isAudioMessage != rhs.isAudioMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendTapbackMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendTapbackMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Target"),
    2: .same(proto: "Type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .tapbackNothing {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendTapbackMessageRequest, rhs: PBSendTapbackMessageRequest) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendMessagePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessagePart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Text"),
    2: .same(proto: "Media"),
    3: .same(proto: "Tapback"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBSendTextMessageRequest?
        var hadOneofValue = false
        if let current = self.part {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.part = .text(v)
        }
      }()
      case 2: try {
        var v: PBSendMediaMessageRequest?
        var hadOneofValue = false
        if let current = self.part {
          hadOneofValue = true
          if case .media(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.part = .media(v)
        }
      }()
      case 3: try {
        var v: PBSendTapbackMessageRequest?
        var hadOneofValue = false
        if let current = self.part {
          hadOneofValue = true
          if case .tapback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.part = .tapback(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.part {
    case .text?: try {
      guard case .text(let v)? = self.part else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .media?: try {
      guard case .media(let v)? = self.part else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tapback?: try {
      guard case .tapback(let v)? = self.part else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendMessagePart, rhs: PBSendMessagePart) -> Bool {
    if lhs.part != rhs.part {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "ReplyTarget"),
    3: .same(proto: "Metadata"),
    4: .same(proto: "Parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._replyTarget) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._replyTarget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.parts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendMessageRequest, rhs: PBSendMessageRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs._replyTarget != rhs._replyTarget {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSendReadReceiptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendReadReceiptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "ReadUpTo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.readUpTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.readUpTo.isEmpty {
      try visitor.visitSingularStringField(value: self.readUpTo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSendReadReceiptRequest, rhs: PBSendReadReceiptRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.readUpTo != rhs.readUpTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSetTypingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetTypingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "Typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.typing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.typing != false {
      try visitor.visitSingularBoolField(value: self.typing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBSetTypingRequest, rhs: PBSetTypingRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.typing != rhs.typing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetChatRequest, rhs: PBGetChatRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetChatAvatarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatAvatarRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetChatAvatarRequest, rhs: PBGetChatAvatarRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MinTimestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetChatsRequest, rhs: PBGetChatsRequest) -> Bool {
    if lhs._minTimestamp != rhs._minTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetContactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetContactRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetContactRequest, rhs: PBGetContactRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetRecentMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetRecentMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "Limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetRecentMessagesRequest, rhs: PBGetRecentMessagesRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGetMessagesAfterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetMessagesAfterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    2: .same(proto: "Timestamp"),
    3: .same(proto: "Limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBGetMessagesAfterRequest, rhs: PBGetMessagesAfterRequest) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBResolveIdentifierRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ResolveIdentifierRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBResolveIdentifierRequest, rhs: PBResolveIdentifierRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBResolveIdentifierResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ResolveIdentifierResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._guid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._guid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBResolveIdentifierResponse, rhs: PBResolveIdentifierResponse) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBResolveIdentifierResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ResolveIdentifierResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Response"),
    2: .same(proto: "Error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBResolveIdentifierResponse?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .response(v)
        }
      }()
      case 2: try {
        var v: PBError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .response?: try {
      guard case .response(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBResolveIdentifierResult, rhs: PBResolveIdentifierResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPrepareDMRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PrepareDMRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._guid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._guid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPrepareDMRequest, rhs: PBPrepareDMRequest) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLogLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LogLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Message"),
    2: .same(proto: "Level"),
    3: .same(proto: "Module"),
    4: .same(proto: "Metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.level) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.level.isEmpty {
      try visitor.visitSingularStringField(value: self.level, fieldNumber: 2)
    }
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBLogLine, rhs: PBLogLine) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.level != rhs.level {return false}
    if lhs.module != rhs.module {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBridgeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BridgeStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "StateEvent", json: "state_event"),
    2: .unique(proto: "Timestamp", json: "timestamp"),
    3: .unique(proto: "TTL", json: "ttl"),
    4: .unique(proto: "Source", json: "source"),
    5: .unique(proto: "Error", json: "error"),
    6: .unique(proto: "Message", json: "message"),
    7: .unique(proto: "UserID", json: "user_id"),
    8: .unique(proto: "RemoteID", json: "remote_id"),
    9: .unique(proto: "RemoteName", json: "remote_name"),
    10: .unique(proto: "Info", json: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateEvent) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._error) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._userID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._remoteID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._remoteName) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stateEvent.isEmpty {
      try visitor.visitSingularStringField(value: self.stateEvent, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 4)
    }
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._remoteID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._remoteName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBBridgeStatus, rhs: PBBridgeStatus) -> Bool {
    if lhs.stateEvent != rhs.stateEvent {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.source != rhs.source {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._remoteID != rhs._remoteID {return false}
    if lhs._remoteName != rhs._remoteName {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContactList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContactList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Contacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBContactList, rhs: PBContactList) -> Bool {
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    10: .same(proto: "Messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._error) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBMessageList, rhs: PBMessageList) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBChatIDList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatIDList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBChatIDList, rhs: PBChatIDList) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPing, rhs: PBPing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Pong"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPong, rhs: PBPong) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBHistoryQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HistoryQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatGUID"),
    15: .same(proto: "beforeDate"),
    16: .same(proto: "afterDate"),
    17: .same(proto: "beforeGUID"),
    18: .same(proto: "afterGUID"),
    19: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatGuid) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._beforeDate) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._afterDate) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self._beforeGuid) }()
      case 18: try { try decoder.decodeSingularStringField(value: &self._afterGuid) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatGuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beforeDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._afterDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._beforeGuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._afterGuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 18)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBHistoryQuery, rhs: PBHistoryQuery) -> Bool {
    if lhs._chatGuid != rhs._chatGuid {return false}
    if lhs._beforeDate != rhs._beforeDate {return false}
    if lhs._afterDate != rhs._afterDate {return false}
    if lhs._beforeGuid != rhs._beforeGuid {return false}
    if lhs._afterGuid != rhs._afterGuid {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBChatQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    15: .same(proto: "messagesAfterDate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 15: try { try decoder.decodeSingularMessageField(value: &self._messagesAfterDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messagesAfterDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBChatQuery, rhs: PBChatQuery) -> Bool {
    if lhs._messagesAfterDate != rhs._messagesAfterDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBEmpty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBEmpty, rhs: PBEmpty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBEmptyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EmptyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Empty"),
    2: .same(proto: "Error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBEmpty?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .empty(v)
        }
      }()
      case 2: try {
        var v: PBError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .empty?: try {
      guard case .empty(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBEmptyResult, rhs: PBEmptyResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBarcelonaStartupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BarcelonaStartupInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SocketPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.socketPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.socketPath.isEmpty {
      try visitor.visitSingularStringField(value: self.socketPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBBarcelonaStartupInfo, rhs: PBBarcelonaStartupInfo) -> Bool {
    if lhs.socketPath != rhs.socketPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "IsResponse"),
    3: .same(proto: "Message"),
    4: .same(proto: "ReadReceipt"),
    5: .same(proto: "TypingNotification"),
    6: .same(proto: "Chat"),
    7: .same(proto: "BridgeStatus"),
    8: .same(proto: "Contact"),
    9: .same(proto: "SendMessageStatus"),
    10: .same(proto: "Log"),
    11: .same(proto: "Contacts"),
    12: .same(proto: "Error"),
    13: .same(proto: "Ack"),
    14: .same(proto: "SendMessage"),
    15: .same(proto: "SendReadReceipt"),
    16: .same(proto: "SetTyping"),
    17: .same(proto: "GetChats"),
    18: .same(proto: "GetChat"),
    19: .same(proto: "GetChatAvatar"),
    20: .same(proto: "GetContact"),
    21: .same(proto: "GetContactList"),
    22: .same(proto: "GetMessagesAfter"),
    23: .same(proto: "PreStartupSync"),
    24: .same(proto: "ResolveIdentifier"),
    25: .same(proto: "PrepareDM"),
    26: .same(proto: "Ping"),
    27: .same(proto: "Pong"),
    28: .same(proto: "Messages"),
    29: .same(proto: "GetRecentMessages"),
    30: .same(proto: "ChatList"),
    31: .same(proto: "Attachment"),
    32: .same(proto: "SendResponse"),
    33: .same(proto: "SyncHookResponse"),
    34: .same(proto: "ResolveIdentifierResponse"),
    35: .same(proto: "Null"),
    36: .same(proto: "GUID"),
    37: .same(proto: "HistoryQuery"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isResponse) }()
      case 3: try {
        var v: PBMessage?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .message(v)
        }
      }()
      case 4: try {
        var v: PBReadReceipt?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .readReceipt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .readReceipt(v)
        }
      }()
      case 5: try {
        var v: PBTypingNotification?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .typingNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .typingNotification(v)
        }
      }()
      case 6: try {
        var v: PBChatInfo?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .chat(v)
        }
      }()
      case 7: try {
        var v: PBBridgeStatus?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .bridgeStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .bridgeStatus(v)
        }
      }()
      case 8: try {
        var v: PBContact?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .contact(v)
        }
      }()
      case 9: try {
        var v: PBSendMessageStatus?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .sendMessageStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .sendMessageStatus(v)
        }
      }()
      case 10: try {
        var v: PBLogLine?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .log(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .log(v)
        }
      }()
      case 11: try {
        var v: PBContactList?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .contacts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .contacts(v)
        }
      }()
      case 12: try {
        var v: PBError?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .error(v)
        }
      }()
      case 13: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.command != nil {try decoder.handleConflictingOneOf()}
          self.command = .ack(v)
        }
      }()
      case 14: try {
        var v: PBSendMessageRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .sendMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .sendMessage(v)
        }
      }()
      case 15: try {
        var v: PBSendReadReceiptRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .sendReadReceipt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .sendReadReceipt(v)
        }
      }()
      case 16: try {
        var v: PBSetTypingRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .setTyping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .setTyping(v)
        }
      }()
      case 17: try {
        var v: PBGetChatsRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getChats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getChats(v)
        }
      }()
      case 18: try {
        var v: PBGetChatRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getChat(v)
        }
      }()
      case 19: try {
        var v: PBGetChatAvatarRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getChatAvatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getChatAvatar(v)
        }
      }()
      case 20: try {
        var v: PBGetContactRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getContact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getContact(v)
        }
      }()
      case 21: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.command != nil {try decoder.handleConflictingOneOf()}
          self.command = .getContactList(v)
        }
      }()
      case 22: try {
        var v: PBGetMessagesAfterRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getMessagesAfter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getMessagesAfter(v)
        }
      }()
      case 23: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.command != nil {try decoder.handleConflictingOneOf()}
          self.command = .preStartupSync(v)
        }
      }()
      case 24: try {
        var v: PBResolveIdentifierRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .resolveIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .resolveIdentifier(v)
        }
      }()
      case 25: try {
        var v: PBPrepareDMRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .prepareDm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .prepareDm(v)
        }
      }()
      case 26: try {
        var v: PBPing?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .ping(v)
        }
      }()
      case 27: try {
        var v: PBPong?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .pong(v)
        }
      }()
      case 28: try {
        var v: PBMessageList?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .messages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .messages(v)
        }
      }()
      case 29: try {
        var v: PBGetRecentMessagesRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .getRecentMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .getRecentMessages(v)
        }
      }()
      case 30: try {
        var v: PBChatIDList?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .chatList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .chatList(v)
        }
      }()
      case 31: try {
        var v: PBAttachment?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .attachment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .attachment(v)
        }
      }()
      case 32: try {
        var v: PBSendResponse?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .sendResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .sendResponse(v)
        }
      }()
      case 33: try {
        var v: PBStartupSyncHookResponse?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .syncHookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .syncHookResponse(v)
        }
      }()
      case 34: try {
        var v: PBResolveIdentifierResponse?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .resolveIdentifierResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .resolveIdentifierResponse(v)
        }
      }()
      case 35: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.command != nil {try decoder.handleConflictingOneOf()}
          self.command = .null(v)
        }
      }()
      case 36: try {
        var v: PBGUID?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .guid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .guid(v)
        }
      }()
      case 37: try {
        var v: PBHistoryQuery?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .historyQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .historyQuery(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.isResponse != false {
      try visitor.visitSingularBoolField(value: self.isResponse, fieldNumber: 2)
    }
    switch self.command {
    case .message?: try {
      guard case .message(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .readReceipt?: try {
      guard case .readReceipt(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .typingNotification?: try {
      guard case .typingNotification(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .chat?: try {
      guard case .chat(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bridgeStatus?: try {
      guard case .bridgeStatus(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .contact?: try {
      guard case .contact(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sendMessageStatus?: try {
      guard case .sendMessageStatus(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .log?: try {
      guard case .log(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .contacts?: try {
      guard case .contacts(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .error?: try {
      guard case .error(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }()
    case .sendMessage?: try {
      guard case .sendMessage(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .sendReadReceipt?: try {
      guard case .sendReadReceipt(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .setTyping?: try {
      guard case .setTyping(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .getChats?: try {
      guard case .getChats(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .getChat?: try {
      guard case .getChat(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .getChatAvatar?: try {
      guard case .getChatAvatar(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .getContact?: try {
      guard case .getContact(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .getContactList?: try {
      guard case .getContactList(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
    }()
    case .getMessagesAfter?: try {
      guard case .getMessagesAfter(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .preStartupSync?: try {
      guard case .preStartupSync(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
    }()
    case .resolveIdentifier?: try {
      guard case .resolveIdentifier(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .prepareDm?: try {
      guard case .prepareDm(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .messages?: try {
      guard case .messages(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .getRecentMessages?: try {
      guard case .getRecentMessages(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .chatList?: try {
      guard case .chatList(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .attachment?: try {
      guard case .attachment(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .sendResponse?: try {
      guard case .sendResponse(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .syncHookResponse?: try {
      guard case .syncHookResponse(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .resolveIdentifierResponse?: try {
      guard case .resolveIdentifierResponse(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .null?: try {
      guard case .null(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 35)
    }()
    case .guid?: try {
      guard case .guid(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .historyQuery?: try {
      guard case .historyQuery(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBPayload, rhs: PBPayload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.isResponse != rhs.isResponse {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
